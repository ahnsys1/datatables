import { Component, OnInit } from '@angular/core';
import { Config } from 'datatables.net';
import DataTable from 'datatables.net-dt';
// The 'datatables.net' package is a dependency of 'datatables.net-dt' and is included automatically.
// The Buttons and Select extensions also have '-dt' packages that include the default styling
// and are generally better suited for module bundlers like Vite.
import 'datatables.net-buttons-dt';
import 'datatables.net-select-dt';
import { DatePipe } from '@angular/common';
import { AddEmployeeComponent } from "../add-employee/add-employee.component";
import { MatDialog, MatDialogRef } from '@angular/material/dialog';
import { Employee } from '../shared/model/Employee';
import { EmployeeService } from '../service/EmployeeService';
import { ConfirmationDialogComponent, ConfirmationDialogData } from '../shared/confirmation-dialog';


@Component({
  selector: 'app-data-tables2',
  templateUrl: './data-tables2.component.html',
  styleUrl: './data-tables2.component.scss'
})
export class DataTables2Component implements OnInit {

  private table!: any;
  private employeeIdToEmployeeMap: Map<string, Employee> = new Map();
  constructor(private dialog: MatDialog, private employeeService: EmployeeService) { }

  ngOnInit(): void {
    const dtOptions: Config = {
      layout: {
        top1Start: {
          buttons: [
            {
              text: 'New employee',
              className: "btn btn-primary",
              action: () => {
                const dialogRef: MatDialogRef<AddEmployeeComponent> =
                  this.dialog.open(AddEmployeeComponent,
                    {
                      disableClose: true,
                      data: { id: null }
                    });
                dialogRef.afterClosed().subscribe(result => {
                  if (!result) {
                    return;
                  }
                  // Bug fix: The arguments to the Employee constructor were incorrect,
                  // causing the 'extn' value to be sent for the 'hasManagerRights' field.
                  const e: Employee = new Employee(
                    "", // id is generated by backend
                    result.name,
                    result.position,
                    result.salary,
                    result.start_date,
                    result.office,
                    result.extn,
                    result.hasManagerRights,
                    result.manager
                  );
                  this.addEmployee(e);
                })
              }
            }
          ]
        }
      },
      columnDefs: [{ "defaultContent": "", "targets": "_all" }],
      columns: [
        { data: 'id', title: 'ID', visible: false },
        { data: 'name', title: 'Name' },
        {
          data: 'manager', title: 'Manager', render: (data, type, row) => {
            if (data !== null) {
              let d = this.employeeIdToEmployeeMap.get(data);
              return d?.name;
            } else {
              return "";
            }
          }
        },
        { data: 'position', title: 'Position' },
        { data: 'office', title: 'Office' },
        { data: 'extn', title: 'extn' },
        {
          data: 'start_date', title: 'Start date', type: 'date', render: (data) => new DatePipe('en-US').transform(data, 'yyyy-MM-dd')
        },
        { data: 'salary', title: 'Salary' },
        { data: 'hasManagerRights', title: "is manager", render: (data) => data ? 'Yes' : 'No' },
        {
          title: 'Actions',
          searchable: false,
          orderable: false,
          render: (data, type, row) => {
            return "<button name='editButton' style='width: 100%' class='btn btn-info'>Edit&nbsp;employee</button><br/>" +
              "<button name='deleteButton' style='width: 100%; background-color: coral' class='btn btn-danger'>Delete&nbsp;employee</button>";
          }
        }
      ],
      rowId: "id",
      drawCallback: () => {
        this.deleteRowEnabled();
        this.editRowEnabled();
      }
    }
    this.table = new DataTable($('#jsonTable'), dtOptions);
    this.getEmployees();
  }


  getEmployees(): void {
    this.employeeService.getEmployeesWithManagers().subscribe({
      next: (res: Employee[]) => {
        for (let i: number = 0; i < res.length; i++) {
          const employee = res[i];
          this.employeeIdToEmployeeMap.set(employee.id, employee);
        }

        this.table.rows.add(res).draw();
      },
      error: (err: any) => {
        alert('Failed to get employees: ' + err.message);
      }
    });
  }


  addEmployee(emp: Employee): void {
    this.employeeService.createEmployee(emp).subscribe({
      next: (res: Employee) => {
        // Add the new employee to the manager map to ensure consistency
        this.employeeIdToEmployeeMap.set(res.id, res);
        this.table.row.add(res).draw();
      },
      error: (err: any) => {
        alert('Failed to add employee: ' + err.message + " " + JSON.stringify(emp));
      }
    });
  }

  editEmployee(emp: Employee, rowToUpdate: any): void {
    this.employeeService.updateEmployee(emp).subscribe({
      next: (res: Employee) => {
        // It's safer to get the most recent data before the update and merge it
        // with the server's response. This prevents data loss if `res` is a partial object.
        const oldData = rowToUpdate.data() || {};
        const newData = { ...oldData, ...res };

        // Update the manager map to prevent stale data if a manager's details changed
        // This is important if the edited employee is also a manager for other employees.
        this.employeeIdToEmployeeMap.set(newData.id, newData);

        // Update the specific row's data, then invalidate all rows to force a
        // re-render of all manager names, and finally redraw the table.
        newData.managerName = newData.manager?.name;
        rowToUpdate.data(newData);
        this.table.draw();
      },
      error: (err: any) => {
        alert('Failed to edit employee: ' + err.message);
      }
    });
  }
  deleteRowEnabled() {
    const deleteButtons = $("#jsonTable tbody tr button[name='deleteButton']");
    deleteButtons.off("click").on("click", (event: any) => {
      const row = $(event.currentTarget).closest('tr');
      let id = row.attr("id");
      // Show confirmation dialog
      const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
        data: {
          title: 'Confirm Delete',
          message: 'Are you sure you want to delete this employee?',
          confirmText: 'Delete',
          cancelText: 'Cancel'
        } as ConfirmationDialogData
      });
      dialogRef.afterClosed().subscribe((confirmed: boolean) => {
        if (confirmed) {
          if (id) {
            this.employeeService.deleteEmployee(id).subscribe({
              next: () => {
                this.employeeIdToEmployeeMap.delete(id);
                this.table.row("#" + id).remove();
                this.table.rows().invalidate().draw(false);
              },
              error: (err: any) => {
                alert('Failed to delete employee: ' + err.message);
              }
            });
          }
        }
      });
    });
  };

  editRowEnabled() {
    const editButtons = $("#jsonTable tbody tr button[name='editButton']");
    editButtons.off("click").on("click", (event: any) => {
      // Get the row element and its corresponding DataTables row object
      const rowElement = $(event.currentTarget).closest('tr');
      let id = rowElement.attr("id");
      if (!id) { return; } // Exit if the row has no ID
      const row = this.table.row("#" + id);
      let rowData = row.data();

      if (rowData == null || rowData == undefined) {
        return;
      }
      const dialogRef: MatDialogRef<AddEmployeeComponent> =
        this.dialog.open(AddEmployeeComponent,
          {
            disableClose: true,
            data: rowData
          });
      dialogRef.afterClosed().subscribe(result => {
        if (!result) {
          return;
        }
        // The `result` object from the dialog contains all the employee data.
        // Re-creating the Employee instance is brittle and can lead to data loss
        // if properties are missing from the result or constructor.
        // By passing the `result` object directly, we ensure all data is preserved.
        // Pass the employee data and the specific row to be updated
        this.editEmployee(result as Employee, row);
      });
    })
  };
}
